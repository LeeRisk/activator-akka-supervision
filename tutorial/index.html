<html>
<head>
    <title>Hello Scala - Activator Template</title>
</head>
<body>
<div>
    <h2>Quick Overview</h2>

    <p>Congratulations! You have just created your first fault-resilient Akka application, nice job!</p>

    <p>Let's have an overview on what we have, and what is the problem we want to solve. This tutorial application
    demonstrates the use of Akka supervision hierarchies to implement reliable systems. This particular example
    demonstrates a calculator service that calculates arithmetic expressions. We will visit each of the components
    shortly, but you might want to take quick look to the components before we move on.</p>

    <ul>
    <li><a href="#code/app/supervision/Expression.scala" class="shortcut">Expression.scala</a>
        contains our "domain model", a very simple representation of arithmetic expressions</li>
    <li><a href="#code/app/supervision/ArithmeticService.scala" class="shortcut">ArithmeticService.scala</a>
        is the entry point for our calculation service</li>
    <li><a href="#code/app/supervision/FlakyExpressionCalculator.scala" class="shortcut">FlakyExpressionCalculator.scala</a>
        is our heavy-lifter, a worker actor that can evaluate an expression concurrently</li>
    <li><a href="#code/app/supervision/Main.scala" class="shortcut">Main.scala</a>
        example code that starts up the calculator service and sends a few jobs to it</li>
    </ul>
</div>
<div>
    <h2>The Expression Model</h2>

    <p>Our service deals with arithmetic expressions on integers involving
    addition, multiplication and (integer) division. In Expression.scala you
        can see a very simple model of these kind of expressions.</p>

<p>Any arithmetic expression is a descendant of Expression, and have a left and
    right side (Const is the only exception) which is also an Expression.</p>

<p>For example, the expression (3 + 5) / (2 * (1 + 1)) could be constructed
    as:</p>
<code><pre>
Divide(
  Add(
    Const(3),
    Const(5)
  ),        // (3 + 5)
  Multiply(
    Const(2),
    Add(
      Const(1),
      Const(1)
    )       // (1 + 1)
  )         // (2 * (1 + 1))
)           // (3 + 5) / (2 * (1 + 1))
</pre></code>

<p>Apart from the encoding of an expression and some pretty printing, our model
    does not provide other services, so lets move on, and see how we can
    calculate the result of such expressions.</p>
</div>
<div>
    <h2>Arithmetic Service</h2>
    <p>Our entry point is the ArithmeticService actor that accepts arithmetic
    expressions, calculates them, and prints the result in the logs. This
    logic is implemented in the receive block. The actor handles two kind of
    messages, Expressions, and Result messages.</p>

    <p>So where does the Result message come from? Who calculates the
    expression? As you see, on the reception of an Expression message we
    create a FlakyExpressionCalculator actor, and pass the expression as a
    parameter to its Props. What happens here is that we delegate the
    calculation work to a worker actor because the work can be "dangerous".</p>
</div>

<div>
    <h2>The Dangers of Arithmetic</h2>

    <p>At first, it might feel strange that we don't calculate the result
    directly but we delegate it to a new actor. The reason for that, is that
        we want to treat the calculation as a dangerous task and isolate its
        execution in a different actor to keep the top level service safe.</p>

    <p>In our example we will see two kinds of failures</p>
    <ul>
    <li>FlakinessException is a dummy exception that we throw randomly to
                        simulate transient failures. We will assume that
        flakiness is temporary, and retrying the calculation is enough to
        eventually get rid of the failure.</li>
    <li>Fatal failures, like ArithmeticException that will not go away no
        matter how many times we retry the task. Division by zero is a good
        example, since it indicates that the expression is invalid, and no
        amount of attempts to calculate it again will fix it.</li>
    </ul>

    <p>To handle these kind of failure modes differently we customized the
        supervisor strategy of ArithmeticService. Our strategy here is to
        restart the child when a recoverable error is detected (in our case
        the dummy FlakynessException), but when arithmetic errors happen --
        like division by zero -- we have no hope to recover therefore we stop the worker.</p>

    <p>We used OneToOneStrategy, since we only want to act on the failing child
    , not on all of our children at the same time.</p>

    <p>We set loggingEnabled to false, since we wanted to use our custom loggin
    g instead of the built-in reporting.</p>


</div>

<div>

<h2>The Joy of Calculation</h2>

<p>So we have now seen our Expression model, our fault modes and how we deal
    with them at the top level, delegating the dangerous work to child
    workers to isolate the failure, and setting Stop or Retry directives
    depending on the nature of the failure (fatal or transient). Now it's
    time to calculate!</p>

    <p>Let's review first our evaluation strategy. When we are facing an expression like ((4 * 4) / (3 + 1)) we might be tempted to calculate (4 * 4) first, then (3 + 1), and then the final division. We can do better: Let's calculate the two sides of the division in parallel!</p>

    <p>To achieve this, our worker delegates the calcuation of the left and right side of the expression it has been given to two child workers of the same type (except in the case of constant, when it just sends its value as Result to the parent). This logic is in preStart() since this is the code that will be executed when an actor starts (and restarts if the postRestart() is not overridden).</p>

    <p>Since any of the sides of the original expression can finish before the other, we have to indicate somehow which side has been calculated, that is why we pass a Position as an argument to workers which they will put in their Result which they send after the calculation finished successfully.</p>

</div>
<div>


<h2>Failing Calculations</h2>

    <p>As you might have observed, we added a method called flakyness() that sometimes just misbehaves (throws an Exception). This simulates a transient failure. Let's see how our FlakyExpressionCalculator deals with faiure situations.</p>

    <p>A supervisor strategy is applied to the children of an actor. Since our children are actually workers for calculating the left and right side of our subexpression, we have to think what different failures mean for us.</p>

    <p>If we encounter a FlakinessException it indicates that one of our workers just made a hiccup and failed to calculate the answer. Since we know this failure is recoverable, we just restart the responsible worker.</p>

    <p>In case of fatal failures we cannot really do anything ourselves. First of all, it indicates that the expression is invalid so restart does not help, second, we are not necessarily the top level worker for the expression. So when an ArithmeticException is encountered it is escalated to the parent. The parent of this actor is either another FlakyExpressionCalculator or the ArithmeticService. Since the calculators all escalate, no matter how deep the exception happened, the ArithmeticService will decide on the fate of the job (in our case, stop it).</p>
</div>
<div>
<h2>When to Split Work? A Small Detour.</h2>

In our example we split expressions recursively and calculated the left and right sides of each of the expressions. The question naturally arises: do we gain anything here regarding performance?

Most likely no. There is additional overhead of splitting up tasks and collecting results, and this case the actual subtasks consist of simple arithmetic operations which are very fast. To really gain in performance, the actual subtasks have to be more heavyweight than this in practice -- but the pattern will be the same nonetheless.

</div>
<div>
    <h2>Where to go from here?</h2>

    <p>After getting confortable with the code, you can try to solve the
        following little excercises:</p>
    <p>Modify <a href="#code/app/supervision/FlakyExpressionCalculator.scala" class="shortcut">FlakyExpressionCalculator</a> to</p>
    <ul>
        <li>contain a job identifier in addition to the expression</li>
        <li>include the identifier in the Result message when the job is finished</li>
    </ul>
    <p>Modify <a href="#code/app/supervision/ArithmeticService.scala" class="shortcut">ArithmeticService</a> so that it</p>
    <ul>
        <li>generates a new job id for each incoming expression</li>
        <li>saves the sender ActorRef of the expression and make it possible to look it up by the job id</li>
        <li>forwards Results to the original requester</li>
    </ul>
    <p>Modify the example <a href="#code/app/supervision/Main.scala" class="shortcut">Main</a> app so that it</p>
    <ul>
        <li>uses akka.pattern.ask to request the result of an expression</li>
    </ul>
    <p>Experiments:</p>
    <ul>
        <li>Try devising more calculation intensive nested jobs instead of
        arithmetic expressions (for example
        transformations of a text document) where concurrency improves
        performance</li>
        <li>Add flakyness() to various places in the calculator and see
            what happens</li>
    </ul>
</div>


</body>
</html>
